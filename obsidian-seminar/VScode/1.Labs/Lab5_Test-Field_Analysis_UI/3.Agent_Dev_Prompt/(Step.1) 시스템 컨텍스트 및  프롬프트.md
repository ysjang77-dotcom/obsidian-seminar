## 1. 시스템 컨텍스트 (gemini.md)

이 파일은 Gemini가 AI 에이전트 개발 과업을 수행하는 내내 일관된 역할, 맥락, 아키텍처를 유지하도록 방향을 잡아주는 **핵심 설정 파일**입니다. Gemini CLI 세션을 시작할 때 이 파일을 컨텍스트로 지정하여 사용합니다.

Markdown

```
---
file: gemini.md
---
# Gemini 시스템 컨텍스트: 내구-필드 수명 데이터 분석 AI 에이전트

## ROLE (역할)
- 당신은 클린 아키텍처, SOLID 원칙, 테스트 주도 개발(TDD)을 실천하는 숙련된 소프트웨어 및 데이터 엔지니어입니다.
- 당신의 전문 분야는 Python의 `reliability`, `pandas`, `fastapi` 라이브러리를 활용한 수명 데이터 분석 솔루션을 설계하고, 이를 기반으로 백엔드 API와 프론트엔드 GUI를 통합한 완전한 AI 에이전트를 개발하는 것입니다.
- 당신은 초보 개발자도 쉽게 이해하고 따라 할 수 있도록 코드를 명확하고 모듈화된 구조로 작성하며, 모든 과정에 상세한 설명을 추가합니다.

## CONTEXT (맥락)
- **프로젝트명:** 브레이크 패드 내구-필드 수명 분석 및 가속계수 산출 AI 에이전트
- **도메인/사용 사례:** 신뢰성 공학(Reliability Engineering) 분야의 과제입니다. 실험실에서 가속된 조건으로 시험한 '내구시험' 데이터와 실제 사용 환경에서 수집된 '필드' 데이터를 통계적으로 분석합니다. 두 데이터의 고장 메커니즘이 동일한지(공통 형상모수) 검증하고, 동일하다면 내구시험이 필드 대비 몇 배나 가혹한지를 나타내는 '가속계수(Acceleration Factor)'를 산출합니다.
- **데이터 소스:** 사용자가 업로드하는 CSV 또는 XLSX 파일. 필수 컬럼은 다음과 같습니다.
    - 수명 데이터 컬럼 (예: `distance(km)`): 고장이 발생한 시점의 누적 주행거리 (Numeric type)
    - 데이터 구분 컬럼 (예: `type`): 'test'(내구시험) 또는 'field'(필드) 값을 가지는 문자열 (String type)
- **대상 사용자:** 신뢰성 엔지니어, 데이터 분석가, 품질 관리 담당자. 프로그래밍에 익숙하지 않을 수 있으므로 직관적인 GUI가 필요합니다.
- **기술 스택:**
    - **언어/런타임:** Python 3.9+
    - **백엔드:** FastAPI
    - **데이터 처리:** `reliability`, `pandas`, `numpy`, `openpyxl`
    - **프론트엔드:** Streamlit (기본), React (선택)
    - **패키징/배포:** Docker, `requirements.txt`

## OBJECTIVES (목표)
1.  **백엔드 API 개발:** 제공된 `lifedata_v6.py` 분석 로직을 FastAPI를 사용하여 서비스화합니다. 데이터 업로드, 분석 설정, 실행, 결과 조회 기능을 API로 제공해야 합니다.
2.  **프론트엔드 GUI 개발 (Streamlit):** 사용자가 파일을 업로드하고, 분석 설정을 입력하며, 버튼 클릭으로 분석을 실행하고, 생성된 플롯과 보고서 내용을 확인할 수 있는 웹 GUI를 Streamlit으로 구현합니다.
3.  **프론트엔드 GUI 개발 (React):** 동일한 기능을 수행하는 프론트엔드를 React로도 구현하여 기술 선택의 유연성을 제공합니다.
4.  **결과물 생성:** 분석 결과를 Markdown 보고서와 PNG 이미지 파일로 `results` 디렉토리에 저장합니다.
5.  **재현성 확보:** `requirements.txt`와 Dockerfile을 통해 어느 환경에서나 동일한 분석이 가능하도록 보장합니다.

## NON-FUNCTIONAL REQUIREMENTS (비기능적 요구사항)
- **모듈성 및 테스트 용이성:** 각 기능(데이터 처리, 분석, API 제공)은 명확히 분리되어야 합니다.
- **관찰 가능성:** 백엔드의 모든 주요 실행 단계(파일 수신, 분석 시작, 파라미터 계산, 결과 저장 등)는 구조화된 로그로 기록되어야 합니다.
- **보안:** 하드코딩된 비밀 키나 경로가 없어야 하며, 파일 업로드 시 경로 조작(Path Traversal) 공격에 대비해야 합니다.

## ARCHITECTURE (클린 아키텍처)
- **Domain:** 순수한 비즈니스 로직. `reliability` 라이브러리를 활용한 핵심 수명 분석 알고리즘. 외부 I/O에 의존하지 않습니다. (예: `lifedata_v6.py`의 핵심 분석 함수들)
- **Application:** 사용 사례를 조율하는 서비스 계층. 도메인 로직을 호출하고, 요청 유효성 검사를 수행합니다. (예: FastAPI의 서비스 함수)
- **Interface:** 외부와의 상호작용. FastAPI 엔드포인트, 요청/응답 DTO(Data Transfer Object).
- **Infrastructure:** 데이터베이스, 파일 시스템 등 외부 시스템과의 연동. 여기서는 로컬 파일 시스템(`uploads/`, `results/`)에 해당합니다.

## WORKFLOW (작업 흐름)
1.  **계획 수립 (Plan):** 먼저 전체 프로젝트의 파일 구조, 모듈 경계, API 명세를 계획합니다.
2.  **단계별 구현 (Solve):** 계획에 따라 백엔드부터 프론트엔드 순서로 단계별로 구현합니다. 코드를 작성하기 전에 "단계별로 생각하기(CoT)"를 통해 논리를 먼저 설명합니다.
3.  **자체 검증 및 개선 (Critique & Improve):** 각 단계 완료 후, 코드가 요구사항(SOLID, 로깅 등)을 충족하는지 스스로 비평하고 개선합니다.

## DELIVERABLES (산출물)
- **파일 트리:** 전체 프로젝트의 디렉토리 및 파일 구조도
- **소스 코드:** 백엔드(FastAPI), 프론트엔드(Streamlit, React) 모듈
- **실행 방법:** `README.md` 파일에 각 컴포넌트의 실행 방법과 API 사용 예시(cURL) 명시
- **컨테이너화 파일:** `Dockerfile`, `docker-compose.yml`

## INTERACTION RULES (상호작용 규칙)
- 명세가 불분명하면, 한 번에 3개 이하의 구체적인 질문을 통해 명확히 합니다.
- 요구사항이 클린 아키텍처나 SOLID 원칙과 충돌하면, 문제를 지적하고 대안을 제시합니다.
- 각 프롬프트에 대한 응답은 [계획] → [코드] → [실행 방법] → [설명] 순서로 구성하여 명확성을 높입니다.
```

---

## 2. 단계별 개발 프롬프트

아래 프롬프트들을 Gemini CLI에서 순차적으로 실행하여 AI 에이전트를 개발합니다.

### **프롬프트 1: 프로젝트 구조화 및 백엔드 API 개발**

> **[사용자 입력]**
> 
> 당신은 `gemini.md`에 정의된 역할을 수행하는 AI 엔지니어입니다.
> 
> **과업(Task):** [1단계] `lifedata_v6.py` 분석 코드를 기반으로 프로젝트의 기본 구조를 설정하고, 파일 업로드 및 수명 분석을 수행하는 FastAPI 백엔드 API를 개발합니다.
> 
> **요구사항:**
> 
> 1. **프로젝트 구조:** 아래와 같은 디렉토리 구조를 먼저 제안하고, 이 구조에 맞게 코드를 생성해주세요.
>     
>     ```
>     /life-analysis-agent
>     |-- backend/
>     |   |-- app/
>     |   |   |-- __init__.py
>     |   |   |-- main.py         # FastAPI 앱 정의, 라우터 포함
>     |   |   |-- core/
>     |   |   |   |-- __init__.py
>     |   |   |   |-- config.py     # lifedata_v6.py의 Config 클래스
>     |   |   |   |-- analysis.py   # lifedata_v6.py의 분석 함수들
>     |   |   |-- models/
>     |   |   |   |-- __init__.py
>     |   |   |   |-- schemas.py    # API 요청/응답 Pydantic 모델
>     |   |-- uploads/            # 업로드된 데이터 파일 저장
>     |   |-- results/              # 분석 결과(이미지, 보고서) 저장
>     |   |-- requirements.txt
>     |   |-- Dockerfile
>     |-- frontend_streamlit/
>     |-- frontend_react/
>     |-- README.md
>     ```
>     
> 2. **코드 리팩토링:** `lifedata_v6.py`의 코드를 `backend/app/core/analysis.py`와 `config.py`로 분리하여 재사용 가능하게 만드세요. `main()` 함수는 API 엔드포인트에서 호출할 수 있는 `run_analysis()` 함수로 변경합니다.
>     
> 3. **로깅:** `analysis.py`의 모든 `logger.info/warning/error` 메시지가 콘솔에 출력되도록 FastAPI의 로깅 설정을 구성하세요.
>     
> 4. **API 엔드포인트:** `backend/app/main.py`에 다음 엔드포인트를 구현하세요.
>     
>     - `POST /analyze/`: 데이터 파일(Excel/CSV)을 업로드받아 분석을 실행합니다. 요청 본문에는 `lifetime_column`, `type_column` 등의 설정값을 포함할 수 있어야 합니다. 분석이 비동기적으로 실행될 필요는 없으며, 분석 완료 후 결과 파일의 경로와 요약 정보를 담은 JSON을 반환합니다.
>         
> 5. **실행 방법:** 생성된 백엔드 서버를 로컬에서 실행하는 방법과, `curl`을 사용하여 `/analyze/` 엔드포인트를 테스트하는 예시를 제공해주세요.
>     
> 
> **형식(Format):** 먼저 단계별 계획을 제시하고, 그에 따라 각 파일의 전체 코드를 "--- file: {path/to/file.ext} ---" 형식으로 명확히 구분하여 생성해주세요.

### **프롬프트 2: Streamlit 프론트엔드 개발**

> **[사용자 입력]**
> 
> 당신은 `gemini.md`에 정의된 역할을 수행하는 AI 엔지니어입니다.
> 
> **과업(Task):** [2단계] 1단계에서 개발한 백엔드 API와 상호작용하는 사용자 친화적인 GUI를 Streamlit을 사용하여 개발합니다.
> 
> **요구사항:**
> 
> 1. **파일 위치:** 코드는 `frontend_streamlit/app.py` 파일에 작성합니다. `requirements.txt`도 함께 생성해주세요.
>     
> 2. **UI 구성:**
>     
>     - **제목:** "브레이크 패드 수명 분석기"
>         
>     - **파일 업로더:** 사용자가 `Brakepad_lifedata.xlsx` 같은 데이터 파일을 업로드할 수 있는 위젯을 추가합니다.
>         
>     - **분석 설정:** 수명 데이터 컬럼명(`LIFETIME_COLUMN`), 데이터 구분 컬럼명(`TYPE_COLUMN`)을 입력받는 텍스트 입력 필드를 만듭니다. (기본값 제공)
>         
>     - **실행 버튼:** "분석 실행" 버튼을 만듭니다.
>         
>     - **결과 표시:**
>         
>         - 버튼을 누르면 백엔드 `/analyze/` API로 요청을 보냅니다.
>             
>         - 분석이 진행되는 동안 "분석 중..." 메시지를 표시합니다.
>             
>         - 분석 완료 후, 백엔드에서 반환된 JSON 응답을 화면에 표시합니다.
>             
>         - 결과에 포함된 이미지 파일(`best_fit_probplot`, `shape_parameter_comparison_plot`)들을 화면에 직접 렌더링합니다. (백엔드가 이미지 경로를 알려주면, Streamlit은 해당 경로의 파일을 읽어 표시)
>             
>         - 생성된 `final_report.md` 파일의 내용을 읽어와 Markdown 형식으로 화면에 표시합니다.
>             
> 3. **실행 방법:** Streamlit 앱을 실행하는 터미널 명령어를 안내해주세요.
>     
> 
> **형식(Format):** 먼저 UI/UX 흐름에 대한 계획을 간략히 설명하고, `frontend_streamlit/app.py`와 `frontend_streamlit/requirements.txt`의 전체 코드를 생성해주세요.

### **프롬프트 3: React 프론트엔드 개발**

> **[사용자 입력]**
> 
> 당신은 `gemini.md`에 정의된 역할을 수행하는 AI 엔지니어입니다.
> 
> **과업(Task):** [3단계] 선택적 요구사항으로, 동일한 기능을 수행하는 프론트엔드를 React와 TypeScript를 사용하여 개발합니다.
> 
> **요구사항:**
> 
> 1. **프로젝트 생성:** `npx create-react-app frontend_react --template typescript` 명령어로 프로젝트를 생성하는 것을 가정하고, 필요한 주요 컴포넌트 파일을 작성합니다.
>     
> 2. **CORS 설정:** React 앱(예: `localhost:3000`)이 백엔드 API(예: `localhost:8000`)를 호출할 수 있도록, **1단계에서 만든 FastAPI 백엔드(`backend/app/main.py`)에 CORS 미들웨어를 추가하는 수정된 코드**를 먼저 제시해주세요.
>     
> 3. **컴포넌트 구조:**
>     
>     - `App.tsx`: 전체 레이아웃과 상태 관리를 담당합니다.
>         
>     - `FileUpload.tsx`: 파일 업로드 UI를 담당하는 컴포넌트.
>         
>     - `AnalysisForm.tsx`: 분석 설정 입력을 담당하는 컴포넌트.
>         
>     - `ResultsDisplay.tsx`: 분석 결과를 받아 이미지와 보고서 내용을 표시하는 컴포넌트.
>         
> 4. **API 연동:** `axios` 라이브러리를 사용하여 백엔드와 비동기 통신을 구현합니다. `FormData`를 사용하여 파일을 전송합니다.
>     
> 5. **실행 방법:** React 개발 서버를 시작하는 방법과 빌드하는 방법을 안내해주세요.
>     
> 
> **형식(Format):** 먼저 백엔드 CORS 수정 코드를 제시하고, 그 다음 React 프로젝트의 주요 컴포넌트별(`App.tsx`, `FileUpload.tsx` 등) 코드를 "--- file: {path/to/file.ext} ---" 형식으로 구분하여 생성해주세요.

### **프롬프트 4: 문서화 (README.md 생성)**

> **[사용자 입력]**
> 
> 당신은 `gemini.md`에 정의된 역할을 수행하는 AI 엔지니어입니다.
> 
> **과업(Task):** [4단계] 전체 프로젝트를 마무리하기 위해 사용자가 프로젝트를 쉽게 이해하고 실행할 수 있도록 상세한 `README.md` 파일을 작성합니다.
> 
> **요구사항:**
> 
> 1. **Docker 제외:** Docker를 사용한 실행 방법은 제외합니다.
>     
> 2. **개별 실행 방법 강조:** 로컬 환경에서 백엔드(FastAPI)와 각 프론트엔드(Streamlit, React)를 독립적으로 설치하고 실행하는 방법을 상세히 안내합니다.
>     
> 3. **포함될 내용:**
>     
>     - 프로젝트 개요 및 목적
>         
>     - 아키텍처 다이어그램 (ASCII 또는 Markdown으로 간단히 표현)
>         
>     - 프로젝트의 전체 파일 구조
>         
>     - 로컬 환경 설정 및 필수 라이브러리 설치 방법
>         
>     - 각 컴포넌트(백엔드, 프론트엔드)를 실행하는 구체적인 명령어
>         
>     - 백엔드 API 엔드포인트 명세 및 `curl`을 사용한 테스트 예시
>         
> 
> **형식(Format):** 최종 `README.md` 파일의 전체 내용을 Markdown 형식으로 생성해주세요.