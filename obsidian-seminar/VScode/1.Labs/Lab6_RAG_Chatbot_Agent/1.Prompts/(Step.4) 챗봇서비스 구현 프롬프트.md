## **Persona (역할)**

당신은 Python, Streamlit, LangChain 라이브러리에 매우 능숙한 **소프트웨어 엔지니어**이자, **신뢰성 공학(Reliability Engineering) 데이터 분석 전문가**입니다. 당신의 전문 분야는 RAG(Retrieval-Augmented Generation) 아키텍처를 활용하여 특정 도메인에 특화된 대화형 AI 어시스턴트를 구축하는 것입니다.

## **Task (과업)**

**RAG 기반의 신뢰성 분석 전문가 챗봇 Streamlit 애플리케이션**을 개발해야 합니다.

이 챗봇은 사전에 구축된 신뢰성 기술자료 Vector DB(FAISS)를 활용하여 사용자의 질문에 답변하고, 신뢰성 전문가로서 심층적인 분석과 추론을 제공해야 합니다.

### **핵심 요구사항:**

1. **Streamlit 기반 UI 구현:**
    
    - 채팅 형식의 인터페이스를 구현합니다.
        
    - 사용자와 챗봇의 대화 기록이 화면에 표시되어야 합니다.
        
    - 사용자가 질문을 입력할 수 있는 텍스트 입력 창이 있어야 합니다.
        
2. **RAG 파이프라인 구축 (LangChain 활용):**
    
    - **VectorDB 활용:** 로컬에 저장된 `faiss_index` 폴더의 FAISS Vector DB를 로드하여 사용합니다. (새로 생성하는 것이 아니라, 기 구축된 DB를 로드해야 합니다.)
        
    - **임베딩 및 LLM 모델:** Google의 Gemini 모델을 사용합니다.
        
        - 임베딩 모델: `GoogleGenerativeAIEmbeddings` (e.g., `models/gemini-embedding-001`)
            
        - LLM: `ChatGoogleGenerativeAI` (e.g., `gemini-2.5-pro` 또는 `gemini-2.5-flash`)
            
    - **참고 코드 활용:** 제공된 `1.RAG_VectorDB_load.py` 파일의 `initialize_vectorstore`와 `create_rag_chain` 함수의 로직을 Streamlit 환경에 맞게 변형하여 적용하세요.
        
3. **신뢰성 분석 전문가 페르소나 적용:**
    
    - 챗봇은 단순히 정보를 검색하여 전달하는 것을 넘어, **신뢰성 분석 전문가**의 관점에서 답변해야 합니다.
        
    - 답변은 객관적인 근거(검색된 문서)를 바탕으로 하되, 전문가적인 통찰과 분석이 포함되어야 합니다.
        
    - 아래와 같은 시스템 프롬프트를 RAG 체인에 적용하여 페르소나를 명확히 하세요.
        
    
    ```
    당신은 수십 년 경력의 신뢰성 공학(Reliability Engineering) 전문가입니다. 당신의 임무는 주어진 기술 문서(Context)를 바탕으로 사용자의 질문에 대해 매우 논리적이고, 체계적이며, 심층적인 답변을 제공하는 것입니다.
    
    **답변 생성 규칙:**
    1.  **전문가적 분석:** 단순히 정보를 요약하지 말고, 각 정보의 인과관계, 중요도, 잠재적 리스크 등을 분석하여 전문가적 견해를 포함하세요.
    2.  **객관적 근거 제시:** 답변의 모든 내용은 반드시 주어진 [Context]에 근거해야 하며, 어떤 문서를 참고했는지 출처(source)를 명확하게 명시해야 합니다.
    3.  **추가 추론 및 제안:** 사용자가 추가 분석을 요청하면, 과거 대화 내용을 모두 고려하여 종합적인 결론을 도출하고, 필요하다면 추가적인 분석 방법이나 대책을 제안하세요.
    4.  **모르는 정보:** [Context]에 없는 내용에 대한 질문에는 "주어진 정보만으로는 답변하기 어렵습니다."라고 명확히 밝히세요.
    ```
    
4. **대화 기록(Memory) 관리:**
    
    - 챗봇은 이전 대화 내용을 기억해야 합니다.
        
    - Streamlit의 `st.session_state`를 활용하여 대화 기록을 관리하고, 사용자의 후속 질문이 이전 대화의 맥락을 유지하도록 구현해야 합니다.
        
    - RAG 체인이 질문을 처리할 때, 현재 질문뿐만 아니라 과거 대화 기록도 함께 고려하여 더 정확하고 맥락에 맞는 답변을 생성하도록 설계하세요.
        

### **논리적 보완 및 고려사항 (사고의 연쇄 - CoT):**

이 과업을 완수하기 위해 **단계별로 생각해서(Let's think step by step)** 아래의 논리적 흐름에 따라 코드를 작성해주세요.

1. **Step 1: 환경 설정 및 라이브러리 임포트**
    
    - `streamlit`, `langchain`, `langchain_google_genai`, `faiss-cpu`, `python-dotenv` 등 필요한 모든 라이브러리를 임포트합니다.
        
    - `.env` 파일에서 `GOOGLE_API_KEY`를 로드할 수 있도록 `load_dotenv()`를 호출합니다.
        
2. **Step 2: Streamlit UI 기본 구조 설정**
    
    - `st.title()`을 사용하여 앱의 제목을 "신뢰성 분석 전문가 챗봇"으로 설정합니다.
        
    - `st.session_state`를 초기화하여 대화 기록(`messages`)을 저장할 리스트를 생성합니다.
        
3. **Step 3: RAG 체인 초기화 함수 작성**
    
    - LangChain, Gemini LLM, FAISS DB를 초기화하고 RAG 체인을 생성하는 과정을 함수로 캡슐화합니다.
        
    - 이 함수는 처음 한 번만 실행되어야 하므로, Streamlit의 `@st.cache_resource` 데코레이터를 사용하여 리소스를 캐싱합니다. 이는 사용자가 메시지를 보낼 때마다 모델과 DB를 다시 로드하는 비효율을 방지합니다.
        
4. **Step 4: 대화 내용 표시**
    
    - `st.session_state.messages`에 저장된 모든 메시지를 순회하며 화면에 `st.chat_message`로 표시합니다.
        
5. **Step 5: 사용자 입력 처리**
    
    - `st.chat_input`을 사용하여 사용자로부터 질문을 받습니다.
        
    - 사용자 질문이 입력되면, `st.session_state.messages`에 사용자 메시지를 추가하고 화면에 다시 표시합니다.
        
6. **Step 6: 챗봇 답변 생성 및 표시**
    
    - 캐싱된 RAG 체인을 사용하여 사용자의 질문(및 대화 기록)에 대한 답변을 생성합니다.
        
    - 생성된 답변을 `st.session_state.messages`에 추가하고 화면에 `st.chat_message`로 표시합니다.
        

## **Format (형식)**

- 결과물은 단일 Python 스크립트 파일(`app.py`)로 제출해주세요.
    
- 코드의 각 주요 부분(함수, 클래스, 로직 블록)에는 상세한 설명 주석을 추가하여 다른 개발자가 쉽게 이해할 수 있도록 작성해주세요.
    
- 에러 처리(e.g., API 키가 없을 경우, FAISS 폴더가 없을 경우)를 위한 `try-except` 구문을 포함하여 안정성을 높여주세요.